/**
 * Property Data Parser
 * Parses property data from various formats (JSON, CSV, Excel)
 * As per plan line 442: "Parse property data (JSON, CSV, Excel)"
 * 
 * Task 3.3 Implementation (lines 847-903):
 * - Subtask 1: CSV/Excel Parser (lines 851-854)
 * - Support .csv, .xlsx formats
 * - Define expected schema
 * - Parse and validate data
 */

import { PropertyDocument } from '../services/ai/rag-types';
import { createServiceLogger } from './logger';
import { parse } from 'csv-parse/sync';
import * as XLSX from 'xlsx';
import { propertyValidationService, ValidationResult } from '../services/validation';

const logger = createServiceLogger('PropertyParser');

/**
 * Raw property data (flexible format)
 */
export interface RawPropertyData {
  id?: string;
  agentId: string;
  projectName: string;
  developerName?: string; // Optional in raw data, will be defaulted
  propertyType: string;
  
  // Location
  city: string;
  district: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  
  // Specifications
  area: number;
  bedrooms: number;
  bathrooms: number;
  floors?: number;
  
  // Pricing
  basePrice: number;
  pricePerMeter: number;
  currency?: string;
  
  // Other
  amenities?: string | string[];
  description?: string;
  deliveryDate?: string | Date;
  images?: string | string[];
  documents?: string | string[];
  videoUrl?: string;
  status?: string;
  
  // Payment plans (can be string or object)
  paymentPlans?: string | any[];
}

/**
 * Property Parser Service
 * Converts raw data into PropertyDocument format
 */
export class PropertyParserService {
  /**
   * Parse raw property data into PropertyDocument format
   * Handles various input formats and normalizes them
   */
  parsePropertyData(raw: RawPropertyData, generateId: boolean = true): PropertyDocument {
    try {
      logger.debug('Parsing property data', {
        projectName: raw.projectName,
        agentId: raw.agentId,
      });

      // Generate ID if needed
      const id = raw.id || (generateId ? this.generatePropertyId(raw) : '');

      // Parse amenities (can be comma-separated string or array)
      const amenities = this.parseArrayField(raw.amenities);

      // Parse images
      const images = this.parseArrayField(raw.images);

      // Parse documents
      const documents = this.parseArrayField(raw.documents);

      // Parse payment plans (can be JSON string or array)
      const paymentPlans = this.parsePaymentPlans(raw.paymentPlans);

      // Parse delivery date (required field, default to 1 year from now if not provided)
      const deliveryDate = raw.deliveryDate 
        ? (raw.deliveryDate instanceof Date ? raw.deliveryDate : new Date(raw.deliveryDate))
        : new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // Default: 1 year from now

      const property: PropertyDocument = {
        id,
        agentId: raw.agentId,
        projectName: raw.projectName,
        developerName: raw.developerName || '', // Required field, default to empty string
        propertyType: raw.propertyType,
        
        location: {
          city: raw.city,
          district: raw.district,
          address: raw.address,
          coordinates: raw.latitude && raw.longitude 
            ? [raw.latitude, raw.longitude] 
            : undefined,
        },
        
        pricing: {
          basePrice: raw.basePrice,
          pricePerMeter: raw.pricePerMeter,
          currency: raw.currency || 'EGP',
        },
        
        specifications: {
          area: raw.area,
          bedrooms: raw.bedrooms,
          bathrooms: raw.bathrooms,
          floors: raw.floors,
        },
        
        amenities,
        paymentPlans,
        deliveryDate,
        description: raw.description || '', // Required field, default to empty string
        images,
        documents,
        videoUrl: raw.videoUrl,
        status: raw.status || 'available',
        
        // These will be generated by RAG service
        embeddingText: '',
        embedding: [],
      };

      logger.info('Property data parsed successfully', {
        id: property.id,
        projectName: property.projectName,
        agentId: property.agentId,
      });

      return property;
    } catch (error) {
      logger.error('Error parsing property data', {
        error: error instanceof Error ? error.message : 'Unknown error',
        projectName: raw.projectName,
      });
      throw error;
    }
  }

  /**
   * Parse array field (handles comma-separated strings or arrays)
   */
  private parseArrayField(field: string | string[] | undefined): string[] {
    if (!field) return [];
    if (Array.isArray(field)) return field;
    if (typeof field === 'string') {
      return field.split(',').map(item => item.trim()).filter(Boolean);
    }
    return [];
  }

  /**
   * Parse payment plans (handles JSON string or array)
   */
  private parsePaymentPlans(field: string | any[] | undefined): any[] {
    if (!field) return [];
    if (Array.isArray(field)) return field;
    if (typeof field === 'string') {
      try {
        const parsed = JSON.parse(field);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }
    return [];
  }

  /**
   * Generate a unique property ID
   * Uses combination of agentId, projectName, and timestamp
   */
  private generatePropertyId(raw: RawPropertyData): string {
    const timestamp = Date.now();
    const projectSlug = raw.projectName
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .substring(0, 30);
    
    return `${raw.agentId}-${projectSlug}-${timestamp}`;
  }

  /**
   * Parse CSV data
   * Task 3.3, Subtask 1: CSV Parser (line 851-854)
   * 
   * Expected CSV format:
   * projectName,developerName,propertyType,city,district,address,latitude,longitude,
   * area,bedrooms,bathrooms,floors,basePrice,pricePerMeter,currency,
   * amenities,description,deliveryDate,images,documents,videoUrl,status
   * 
   * @param csvData - CSV string content
   * @param agentId - Agent ID to associate with properties
   * @returns Array of parsed property data
   */
  parseCSV(csvData: string, agentId: string): RawPropertyData[] {
    try {
      logger.info('Parsing CSV data', { agentId });

      // Parse CSV with headers
      const records = parse(csvData, {
        columns: true, // First row is headers
        skip_empty_lines: true,
        trim: true,
        cast: true, // Auto-cast numbers
        cast_date: false, // Don't auto-cast dates (we'll handle manually)
        relax_column_count: true, // Allow rows with fewer columns
        on_record: (record) => {
          // Convert empty strings to undefined
          Object.keys(record).forEach(key => {
            if (record[key] === '') {
              record[key] = undefined;
            }
          });
          return record;
        },
      });

      if (!records || records.length === 0) {
        logger.warn('No records found in CSV');
        return [];
      }

      logger.info(`Parsed ${records.length} records from CSV`);

      // Map CSV records to RawPropertyData format
      const properties: RawPropertyData[] = records.map((record: any, index: number) => {
        try {
          return this.mapCsvRowToPropertyData(record, agentId);
        } catch (error) {
          logger.error('Error mapping CSV row', {
            rowIndex: index,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
          throw new Error(`Row ${index + 2}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      });

      logger.info(`Successfully mapped ${properties.length} properties from CSV`);
      return properties;
    } catch (error) {
      logger.error('Error parsing CSV', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw new Error(`CSV parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Parse Excel data
   * Task 3.3, Subtask 1: Excel Parser (line 851-854)
   * 
   * Supports .xlsx and .xls formats
   * Reads from first sheet or sheet named "Properties"
   * 
   * @param excelBuffer - Excel file buffer
   * @param agentId - Agent ID to associate with properties
   * @returns Array of parsed property data
   */
  parseExcel(excelBuffer: Buffer, agentId: string): RawPropertyData[] {
    try {
      logger.info('Parsing Excel data', { agentId, bufferSize: excelBuffer.length });

      // Read workbook from buffer
      const workbook = XLSX.read(excelBuffer, { 
        type: 'buffer',
        cellDates: false, // We'll handle dates manually
        cellText: false,
      });

      if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
        throw new Error('Excel file contains no sheets');
      }

      // Get first sheet or sheet named "Properties"
      let sheetName = workbook.SheetNames[0];
      if (workbook.SheetNames.includes('Properties')) {
        sheetName = 'Properties';
      }

      logger.info(`Reading from sheet: ${sheetName}`);

      const worksheet = workbook.Sheets[sheetName];
      if (!worksheet) {
        throw new Error(`Sheet "${sheetName}" not found`);
      }

      // Convert sheet to JSON
      // { header: 1 } means first row is headers
      const records: any[] = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        defval: undefined, // Empty cells become undefined
        blankrows: false, // Skip blank rows
      });

      if (records.length < 2) {
        logger.warn('Excel file has no data rows (only headers or empty)');
        return [];
      }

      // First row is headers
      const headers = records[0];
      const dataRows = records.slice(1);

      logger.info(`Parsed ${dataRows.length} data rows from Excel`);

      // Map rows to property data
      const properties: RawPropertyData[] = dataRows
        .filter((row: any[]) => {
          // Skip completely empty rows
          return row.some(cell => cell !== undefined && cell !== null && cell !== '');
        })
        .map((row: any[], index: number) => {
          try {
            // Convert row array to object using headers
            const record: any = {};
            headers.forEach((header: string, i: number) => {
              if (header && row[i] !== undefined && row[i] !== null && row[i] !== '') {
                record[header] = row[i];
              }
            });

            return this.mapCsvRowToPropertyData(record, agentId);
          } catch (error) {
            logger.error('Error mapping Excel row', {
              rowIndex: index + 2, // +2 because index starts at 0 and we skip header
              error: error instanceof Error ? error.message : 'Unknown error',
            });
            throw new Error(`Row ${index + 2}: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        });

      logger.info(`Successfully mapped ${properties.length} properties from Excel`);
      return properties;
    } catch (error) {
      logger.error('Error parsing Excel', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw new Error(`Excel parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Map CSV/Excel row to RawPropertyData format
   * Handles type conversions and field mapping
   * 
   * @param record - Row object from CSV/Excel
   * @param agentId - Agent ID to associate with property
   * @returns Mapped property data
   */
  private mapCsvRowToPropertyData(record: any, agentId: string): RawPropertyData {
    // Helper to safely parse numbers
    const parseNumber = (value: any): number | undefined => {
      if (value === undefined || value === null || value === '') return undefined;
      const num = typeof value === 'number' ? value : parseFloat(String(value).replace(/,/g, ''));
      return isNaN(num) ? undefined : num;
    };

    // Helper to safely parse integers
    const parseInt = (value: any): number | undefined => {
      const num = parseNumber(value);
      return num !== undefined ? Math.floor(num) : undefined;
    };

    // Helper to parse payment plans from JSON string or leave as is
    const parsePaymentPlans = (value: any): any[] | undefined => {
      if (!value) return undefined;
      if (Array.isArray(value)) return value;
      if (typeof value === 'string') {
        try {
          const parsed = JSON.parse(value);
          return Array.isArray(parsed) ? parsed : undefined;
        } catch {
          return undefined;
        }
      }
      return undefined;
    };

    const mapped: RawPropertyData = {
      agentId,
      projectName: record.projectName || record.project_name || '',
      developerName: record.developerName || record.developer_name,
      propertyType: record.propertyType || record.property_type || '',
      
      // Location
      city: record.city || '',
      district: record.district || '',
      address: record.address,
      latitude: parseNumber(record.latitude),
      longitude: parseNumber(record.longitude),
      
      // Specifications
      area: parseNumber(record.area) || 0,
      bedrooms: parseInt(record.bedrooms) || 0,
      bathrooms: parseInt(record.bathrooms) || 0,
      floors: parseInt(record.floors),
      
      // Pricing
      basePrice: parseNumber(record.basePrice || record.base_price) || 0,
      pricePerMeter: parseNumber(record.pricePerMeter || record.price_per_meter) || 0,
      currency: record.currency || 'EGP',
      
      // Other fields
      amenities: record.amenities, // Will be parsed by parseArrayField
      description: record.description,
      deliveryDate: record.deliveryDate || record.delivery_date,
      images: record.images,
      documents: record.documents,
      videoUrl: record.videoUrl || record.video_url,
      status: record.status || 'available',
      paymentPlans: parsePaymentPlans(record.paymentPlans || record.payment_plans),
    };

    return mapped;
  }

  /**
   * Validate property data
   * Uses PropertyValidationService to avoid duplication
   * Task 3.3, Subtask 2: Data Validation Rules (lines 856-880)
   * 
   * @param raw - Raw property data to validate
   * @returns Validation result
   */
  validatePropertyData(raw: RawPropertyData): ValidationResult {
    return propertyValidationService.validatePropertyData(raw);
  }

  /**
   * Validate batch of properties
   * Task 3.3, Subtask 2: Batch validation support
   * 
   * @param properties - Array of properties to validate
   * @returns Array of validation results
   */
  validateBatch(properties: RawPropertyData[]): ValidationResult[] {
    return propertyValidationService.validateBatch(properties);
  }
}

// Export singleton instance
export const propertyParser = new PropertyParserService();

