/**
 * Property Data Parser
 * Parses property data from various formats (JSON, CSV, Excel)
 * As per plan line 442: "Parse property data (JSON, CSV, Excel)"
 * 
 * Full implementation will be in Task 3.3 (lines 847-903)
 * This provides basic parsing utilities
 */

import { PropertyDocument } from '../services/ai/rag-types';
import { createServiceLogger } from './logger';

const logger = createServiceLogger('PropertyParser');

/**
 * Raw property data (flexible format)
 */
export interface RawPropertyData {
  id?: string;
  agentId: string;
  projectName: string;
  developerName?: string; // Optional in raw data, will be defaulted
  propertyType: string;
  
  // Location
  city: string;
  district: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  
  // Specifications
  area: number;
  bedrooms: number;
  bathrooms: number;
  floors?: number;
  
  // Pricing
  basePrice: number;
  pricePerMeter: number;
  currency?: string;
  
  // Other
  amenities?: string | string[];
  description?: string;
  deliveryDate?: string | Date;
  images?: string | string[];
  documents?: string | string[];
  videoUrl?: string;
  status?: string;
  
  // Payment plans (can be string or object)
  paymentPlans?: string | any[];
}

/**
 * Property Parser Service
 * Converts raw data into PropertyDocument format
 */
export class PropertyParserService {
  /**
   * Parse raw property data into PropertyDocument format
   * Handles various input formats and normalizes them
   */
  parsePropertyData(raw: RawPropertyData, generateId: boolean = true): PropertyDocument {
    try {
      logger.debug('Parsing property data', {
        projectName: raw.projectName,
        agentId: raw.agentId,
      });

      // Generate ID if needed
      const id = raw.id || (generateId ? this.generatePropertyId(raw) : '');

      // Parse amenities (can be comma-separated string or array)
      const amenities = this.parseArrayField(raw.amenities);

      // Parse images
      const images = this.parseArrayField(raw.images);

      // Parse documents
      const documents = this.parseArrayField(raw.documents);

      // Parse payment plans (can be JSON string or array)
      const paymentPlans = this.parsePaymentPlans(raw.paymentPlans);

      // Parse delivery date (required field, default to 1 year from now if not provided)
      const deliveryDate = raw.deliveryDate 
        ? (raw.deliveryDate instanceof Date ? raw.deliveryDate : new Date(raw.deliveryDate))
        : new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // Default: 1 year from now

      const property: PropertyDocument = {
        id,
        agentId: raw.agentId,
        projectName: raw.projectName,
        developerName: raw.developerName || '', // Required field, default to empty string
        propertyType: raw.propertyType,
        
        location: {
          city: raw.city,
          district: raw.district,
          address: raw.address,
          coordinates: raw.latitude && raw.longitude 
            ? [raw.latitude, raw.longitude] 
            : undefined,
        },
        
        pricing: {
          basePrice: raw.basePrice,
          pricePerMeter: raw.pricePerMeter,
          currency: raw.currency || 'EGP',
        },
        
        specifications: {
          area: raw.area,
          bedrooms: raw.bedrooms,
          bathrooms: raw.bathrooms,
          floors: raw.floors,
        },
        
        amenities,
        paymentPlans,
        deliveryDate,
        description: raw.description || '', // Required field, default to empty string
        images,
        documents,
        videoUrl: raw.videoUrl,
        status: raw.status || 'available',
        
        // These will be generated by RAG service
        embeddingText: '',
        embedding: [],
      };

      logger.info('Property data parsed successfully', {
        id: property.id,
        projectName: property.projectName,
        agentId: property.agentId,
      });

      return property;
    } catch (error) {
      logger.error('Error parsing property data', {
        error: error instanceof Error ? error.message : 'Unknown error',
        projectName: raw.projectName,
      });
      throw error;
    }
  }

  /**
   * Parse array field (handles comma-separated strings or arrays)
   */
  private parseArrayField(field: string | string[] | undefined): string[] {
    if (!field) return [];
    if (Array.isArray(field)) return field;
    if (typeof field === 'string') {
      return field.split(',').map(item => item.trim()).filter(Boolean);
    }
    return [];
  }

  /**
   * Parse payment plans (handles JSON string or array)
   */
  private parsePaymentPlans(field: string | any[] | undefined): any[] {
    if (!field) return [];
    if (Array.isArray(field)) return field;
    if (typeof field === 'string') {
      try {
        const parsed = JSON.parse(field);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }
    return [];
  }

  /**
   * Generate a unique property ID
   * Uses combination of agentId, projectName, and timestamp
   */
  private generatePropertyId(raw: RawPropertyData): string {
    const timestamp = Date.now();
    const projectSlug = raw.projectName
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .substring(0, 30);
    
    return `${raw.agentId}-${projectSlug}-${timestamp}`;
  }

  /**
   * Parse CSV data
   * Note: Full CSV parsing implementation will be in Task 3.3
   * This is a placeholder that shows the interface
   */
  parseCSV(csvData: string): RawPropertyData[] {
    logger.warn('CSV parsing not fully implemented yet - will be completed in Task 3.3');
    // TODO: Task 3.3 - Implement full CSV parser
    return [];
  }

  /**
   * Parse Excel data
   * Note: Full Excel parsing implementation will be in Task 3.3
   * This is a placeholder that shows the interface
   */
  parseExcel(excelBuffer: Buffer): RawPropertyData[] {
    logger.warn('Excel parsing not fully implemented yet - will be completed in Task 3.3');
    // TODO: Task 3.3 - Implement full Excel parser with xlsx library
    return [];
  }

  /**
   * Validate property data
   * Ensures all required fields are present
   */
  validatePropertyData(raw: RawPropertyData): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Required fields
    if (!raw.agentId) errors.push('agentId is required');
    if (!raw.projectName) errors.push('projectName is required');
    if (!raw.propertyType) errors.push('propertyType is required');
    if (!raw.city) errors.push('city is required');
    if (!raw.district) errors.push('district is required');
    if (!raw.area || raw.area <= 0) errors.push('area must be positive number');
    if (!raw.bedrooms || raw.bedrooms < 0) errors.push('bedrooms must be non-negative');
    if (!raw.bathrooms || raw.bathrooms < 0) errors.push('bathrooms must be non-negative');
    if (!raw.basePrice || raw.basePrice <= 0) errors.push('basePrice must be positive number');
    if (!raw.pricePerMeter || raw.pricePerMeter <= 0) errors.push('pricePerMeter must be positive number');

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}

// Export singleton instance
export const propertyParser = new PropertyParserService();

